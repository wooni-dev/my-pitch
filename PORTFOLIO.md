# My Pitch - 포트폴리오 문서

> 음악 파일에서 음정을 자동 분석하여 악보로 변환하는 웹 서비스

🌐 **[My Pitch 바로가기 →](https://my-pitch.work/)** - 배포된 서비스를 직접 사용해보실 수 있습니다.

---

## 📌 프로젝트 개요

### 프로젝트 동기
노래방에서 녹음한 내 음정을 확인하고 싶다는 개인적 필요에서 출발하여, 복잡한 음악 이론 지식 없이도 누구나 자신의 음정을 악보로 시각화하여 확인할 수 있는 서비스를 개발했습니다.

### 핵심 기능
- 🎵 **음원 분리**: Demucs AI 모델을 이용한 보컬/MR 분리
- 🎼 **음정 분석**: Librosa를 이용한 음정 추출
- 📊 **악보 시각화**: VexFlow를 활용한 악보 렌더링
- 🎧 **동기화 재생**: 악보와 오디오 동기화

### 기술 스택

- **Frontend**: Next.js, VexFlow
- **Backend**: Python, Flask, Librosa, Demucs
- **Infrastructure**: Docker, Nginx, MinIO

---

## 🎬 서비스 소개

> 💡 **썸네일을 클릭하면 YouTube에서 영상을 시청할 수 있습니다.**
>
> *※ 저작권 문제로 모든 영상의 음성을 제거했습니다.*

<table>
<tr>
<td width="50%">

### 1. My Pitch 사용법
[![My Pitch 사용법](https://img.youtube.com/vi/IJ230xx4sC8/maxresdefault.jpg)](https://youtu.be/IJ230xx4sC8)

음악 파일 업로드부터 음원 분리, 음정 분석, 악보 변환까지 전체 사용 흐름을 보여줍니다. VexFlow를 활용한 악보 렌더링과 오디오 동기화 재생 기능을 확인할 수 있습니다.

</td>
<td width="50%">

### 2. My Pitch 순번 대기
[![My Pitch 순번 대기](https://img.youtube.com/vi/FFLvpNCe9uM/maxresdefault.jpg)](https://youtu.be/FFLvpNCe9uM)

인메모리 작업 큐 시스템의 동작 방식과 대기열 UX를 보여줍니다. 이벤트 기반 워커를 통한 순차 처리와 사용자에게 실시간으로 대기 순번을 안내하는 방식을 확인할 수 있습니다.

</td>
</tr>
</table>

<table>
<tr>
<td width="50%">

### 3. MinIO 파일 관리
[![MinIO 파일 관리](https://img.youtube.com/vi/J6G-9mkcc1Y/maxresdefault.jpg)](https://youtu.be/J6G-9mkcc1Y)

악보 변환 과정에서 생성되는 원본 파일, 분리된 보컬/MR 파일들을 MinIO 오브젝트 스토리지에서 관리하는 방법을 보여줍니다. Presigned URL을 통한 안전한 파일 접근 방식을 확인할 수 있습니다.

</td>
<td width="50%">

### 4. My Pitch 모바일 사용법
[![My Pitch 모바일 사용법](https://img.youtube.com/vi/dIEL0GkP-BA/maxresdefault.jpg)](https://youtu.be/dIEL0GkP-BA)

모바일 환경에서의 반응형 디자인과 사용자 경험을 보여줍니다. 화면 크기에 따라 자동으로 조정되는 악보 레이아웃과 터치 인터랙션을 확인할 수 있습니다.

</td>
</tr>
</table>

---

## 🔄 서비스 플로우

1. **파일 업로드** → 음악 파일을 서버에 업로드하고 대기열에 등록
2. **음원 분리** → AI 모델이 보컬과 반주를 분리
3. **음정 분석** → 분리된 보컬에서 음정 추출
4. **악보 생성** → 추출된 음정을 악보로 시각화
5. **결과 확인** → 오디오 재생과 동기화된 악보 제공

---

## 🏗️ 아키텍처 설계

### 시스템 아키텍처

#### 개발 환경 (외부 서버 사용)
> GPU 없는 로컬 환경에서 외부 Colab 서버로 음원 분리 요청

```
┌─────────────┐
│   Client    │  Next.js (React) - 악보 렌더링 및 오디오 플레이어
│  (Browser)  │  - 3초 폴링으로 작업 상태 조회
└──────┬──────┘
       │ HTTP
┌──────▼──────┐
│    Nginx    │  리버스 프록시, 라우팅
│   (Proxy)   │
└──────┬──────┘
       │
   ┌───┴───────────┬─────────┐
   │               │         │
┌──▼───────────┐ ┌─▼────┐ ┌──▼───────┐
│  Flask API   │ │Client│ │  MinIO   │  오브젝트 스토리지
│              │ │Next  │ │(Storage) │  - 원본 파일만 저장
│ ┌──────────┐ │ └──────┘ └──────────┘
│ │ Job Queue│ │  인메모리 작업 대기열
│ │  (deque) │ │  - 순차 처리
│ │          │ │  - 대기열 제한 (MAX: 3명)
│ │ [Job1]   │ │  - 이벤트 기반 워커
│ │ [Job2]   │ │
│ │ [Job3]   │ │
│ └──────┬───┘ │
└────────┼─────┘
         │ HTTPS
         ▼
┌─────────────────┐
│  Colab Server   │  외부 음원 분리 서버
│  (Demucs GPU)   │  - 보컬/MR 분리
└─────────────────┘  - 분리 파일 반환
```

#### 배포 환경 (로컬 처리)
> GPU 장착 서버에서 로컬 Demucs 모델 직접 실행

```
┌─────────────┐
│   Client    │  Next.js (React) - 악보 렌더링 및 오디오 플레이어
│  (Browser)  │  - 3초 폴링으로 작업 상태 조회
└──────┬──────┘
       │ HTTPS
┌──────▼──────┐
│    Nginx    │  리버스 프록시, 라우팅, HTTPS 처리
│   (Proxy)   │  - Let's Encrypt SSL/TLS
│             │  - Certbot 자동 갱신 (12시간마다 체크)
└──────┬──────┘
       │
   ┌───┴───────────┬─────────┐
   │               │         │
┌──▼───────────┐ ┌─▼────┐ ┌──▼───────┐
│  Flask API   │ │Client│ │  MinIO   │  오브젝트 스토리지
│              │ │Next  │ │(Storage) │  - 원본 파일
│ ┌──────────┐ │ └──────┘ └────▲─────┘  - 분리된 파일
│ │ Job Queue│ │               │
│ │  (deque) │ │  인메모리 작업 대기열          │
│ │          │ │  - 순차 처리                  │
│ │ [Job1]   │ │  - 대기열 제한 (MAX: 3명)     │
│ │ [Job2]   │ │  - 이벤트 기반 워커           │
│ │ [Job3]   │ │                              │
│ └──────┬───┘ │                              │
│        │     │                              │
│  ┌─────▼────┐│                              │
│  │ Demucs AI││  GPU 자동 감지 (CUDA/CPU)     │
│  │(로컬 GPU) ││  - 보컬/MR 분리              │
│  └─────┬────┘│  - MinIO 저장                │
└────────┼─────┘                              │
         └────────────────────────────────────┘
```

---

## 💡 기술 선택 이유

### 폴링 방식 선택

실시간 통신 기술(WebSocket, SSE) 대신 3초 간격 폴링 방식을 선택한 이유:

- **서비스 검증 우선**: 복잡한 실시간 통신 인프라를 구축하기 전에, 서비스 자체의 가치를 먼저 검증하는 것이 중요하다고 판단했습니다.
- **현재 규모에 적합**: 대기열 제한(MAX 3명)과 작업 특성상 3초 간격 폴링으로 충분한 사용자 경험을 제공할 수 있습니다.
- **구현 복잡도 감소**: WebSocket 인프라 구축 및 연결 관리보다 폴링 방식이 개발 및 배포가 단순하여 빠른 출시가 가능했습니다.
- **확장 계획**: 접속자 수가 증가하면 WebSocket 또는 SSE로 전환할 예정입니다.

> 과도한 엔지니어링을 피하고, 현재 서비스 규모에 맞는 기술을 선택하여 빠르게 시장 검증을 진행하는 것을 우선시했습니다.

### Demucs AI 모델 선택

음원 분리 AI 모델로 Demucs를 선택한 배경:

**비교 테스트 진행**
- **Spleeter**: 처리 속도는 빠르지만 보컬/MR 분리 정확도가 상대적으로 낮음
- **BS-RoFormer**: 사전 학습되지 않은 모델로 직접 학습이 필요하여 제외
- **Demucs**: 처리 속도와 분리 정확도의 밸런스가 가장 우수

**선택 이유**
- 음정 분석을 위해서는 정확한 보컬 분리가 필수적
- 사용자가 기다릴 수 있는 합리적인 처리 시간 제공
- MDX Challenge 2021 (Music Demixing Challenge) 우승 모델로 검증된 성능

### Certbot (Let's Encrypt)

HTTPS 보안 통신을 위한 SSL/TLS 인증서 자동 관리:

- **무료 인증서**: Let's Encrypt를 통한 무료 SSL/TLS 인증서 발급
- **자동 갱신**: Certbot이 12시간마다 인증서 만료 여부를 체크하고 자동 갱신
- **보안 강화**: 모든 클라이언트-서버 통신을 HTTPS로 암호화하여 데이터 보호

> [generate-ssl-cert.sh](scripts/generate-ssl-cert.sh) 스크립트로 초기 인증서 발급을 자동화했습니다.

### MinIO 접근 방식 (SSH 터널링)

MinIO 관리자 페이지 접근을 SSH 터널링으로 제한:

- **보안 강화**: 관리자 페이지를 외부에 노출하지 않고 SSH 터널링을 통해서만 접근 가능
- **권한 관리**: 서버 SSH 접근 권한이 있는 관리자만 MinIO 콘솔에 접근 가능
- **공격 표면 최소화**: 불필요한 포트를 외부에 노출하지 않아 보안 위험 감소

> 사용자는 Presigned URL을 통해 안전하게 파일에 접근하며, 관리 작업은 로컬 터널링을 통해서만 수행됩니다.